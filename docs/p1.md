# Project 1: Threads

## Preliminaries

>Fill in your name and email address.

Rundong Yang <3096842671@qq.com>

>If you have any preliminary comments on your submission, notes for the
>TAs, please give them here.



>Please cite any offline or online sources you consulted while
>preparing your submission, other than the Pintos documentation, course
>text, lecture notes, and course staff.



## Alarm Clock

#### DATA STRUCTURES

>A1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.

In [threads/thread.h](../src/threads/thread.h):
```c
struct thread
  {
    /* Owned by thread.c. */
    tid_t tid;                          /**< Thread identifier. */
    enum thread_status status;          /**< Thread state. */
    char name[16];                      /**< Name (for debugging purposes). */
    uint8_t *stack;                     /**< Saved stack pointer. */
    int priority;                       /**< Priority. */
    struct list_elem allelem;           /**< List element for all threads list. */

    /* Shared between thread.c and synch.c. */
    struct list_elem elem;              /**< List element. */

    /* Shared between thread.c and device/timer.c. */
    int64_t ticks;                      /**< Sleep until timer ticks */

#ifdef USERPROG
    /* Owned by userprog/process.c. */
    uint32_t *pagedir;                  /**< Page directory. */
#endif

    /* Owned by thread.c. */
    unsigned magic;                     /**< Detects stack overflow. */
  };
```

Add the member `ticks` to cause the thread to sleep until timer ticks reaches 
this number.

In [threads/thread.h](../src/threads/thread.h):
```c
/** States in a thread's life cycle. */
enum thread_status
  {
    THREAD_RUNNING,     /**< Running thread. */
    THREAD_READY,       /**< Not running but ready to run. */
    THREAD_BLOCKED,     /**< Waiting for an event to trigger. */
    THREAD_DYING,       /**< About to be destroyed. */
    THREAD_SLEEPING     /**< Sleeping (for debug) */
  };
```

Add a special thread state: `THREAD_SLEEPING` to denote a sleepint thread. This may be 
useful for debugging.

In [threads/thread.c](../src/threads/thread.c):
```c
/** List of all sleeping processes. */
static struct list sleep_list;
```

Keep track of sleeping threads(elem member of sleeping threads).

#### ALGORITHMS

>A2: Briefly describe what happens in a call to timer_sleep(),
>including the effects of the timer interrupt handler.

A call to timer sleep will cause the currently running thread to do the following:

<ul>
  <li>Set the member ticks of running thread;</li>
  <li>Force the thread to yield the CPU;</li>
  <li>Put the thread into sleep list;</li>
</ul>

Upon a timer interrupt, we should scan the sleep list, and decrement the ticks of each sleeping thread.
Add a thread back to ready list if ticks become zero.

>A3: What steps are taken to minimize the amount of time spent in
>the timer interrupt handler?

Here we introduce a sleep list to store the elem member of all sleeping threads.
In this scenario, the kernel doesn't have to loop up the entire thread list for 
sleeping threads upon timer interrupt, hence time is saved.


#### SYNCHRONIZATION

>A4: How are race conditions avoided when multiple threads call
>timer_sleep() simultaneously?

We turn off external interrupts to avoid race condition.


>A5: How are race conditions avoided when a timer interrupt occurs
>during a call to timer_sleep()?


Same answer as `A4`.

#### RATIONALE

>A6: Why did you choose this design?  In what ways is it superior to
>another design you considered?

We choose this design because it is easy to understand and implement. It's also 
free from race conditions.


## Priority Scheduling

#### DATA STRUCTURES

>B1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



>B2: Explain the data structure used to track priority donation.
>Use ASCII art to diagram a nested donation.  (Alternately, submit a
>.png file.)



#### ALGORITHMS

>B3: How do you ensure that the highest priority thread waiting for
>a lock, semaphore, or condition variable wakes up first?



>B4: Describe the sequence of events when a call to lock_acquire()
>causes a priority donation.  How is nested donation handled?



>B5: Describe the sequence of events when lock_release() is called
>on a lock that a higher-priority thread is waiting for.



#### SYNCHRONIZATION

>B6: Describe a potential race in thread_set_priority() and explain
>how your implementation avoids it.  Can you use a lock to avoid
>this race?



#### RATIONALE

>B7: Why did you choose this design?  In what ways is it superior to
>another design you considered?



## Advanced Scheduler

#### DATA STRUCTURES

>C1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.

In [threads/frac.h](../src/threads/frac.h):
```c
typedef struct frac 
  {
    int dat;   /**< place to hold the fractional number */
  } 
frac_t;

/** zero in fractional repr */
static const frac_t FRAC_ZERO = {0};
/** max frac number, equivalent to 131071.99 */
static const frac_t FRAC_MAX  = {2147483647};
/** min frac number, equivalent to -131072 */
static const frac_t FRAC_MIN  = {1 << 31};
```

Here we introduce the fractional number type in the `17-14` representation. We also provide 
3 contants: `FRAC_ZERO`, `FRAC_MAX` and `FRAC_MIN`.

#### ALGORITHMS

>C2: How is the way you divided the cost of scheduling between code
>inside and outside interrupt context likely to affect performance?



#### RATIONALE

>C3: Briefly critique your design, pointing out advantages and
>disadvantages in your design choices.  If you were to have extra
>time to work on this part of the project, how might you choose to
>refine or improve your design?



>C4: The assignment explains arithmetic for fixed-point math in
>detail, but it leaves it open to you to implement it.  Why did you
>decide to implement it the way you did?  If you created an
>abstraction layer for fixed-point math, that is, an abstract data
>type and/or a set of functions or macros to manipulate fixed-point
>numbers, why did you do so?  If not, why not?

## Testing
Copy your testing result here(NO. PLEASE DO NOT CHEAT ON THIS).
```
pass tests/threads/alarm-single
pass tests/threads/alarm-simple
pass tests/threads/alarm-multiple
pass tests/threads/alarm-simultaneous
pass tests/threads/alarm-priority
pass tests/threads/alarm-zero
pass tests/threads/alarm-simple2
pass tests/threads/alarm-moderate
pass tests/threads/priority-lock
pass tests/threads/alarm-negative
pass tests/threads/priority-change
FAIL tests/threads/priority-donate-one
FAIL tests/threads/priority-donate-multiple
FAIL tests/threads/priority-donate-multiple2
FAIL tests/threads/priority-donate-nest
FAIL tests/threads/priority-donate-sema
FAIL tests/threads/priority-donate-lower
pass tests/threads/priority-fifo
pass tests/threads/priority-preempt
pass tests/threads/priority-sema
pass tests/threads/priority-condvar
FAIL tests/threads/priority-donate-chain
pass tests/threads/mlfqs-load-1
FAIL tests/threads/mlfqs-load-60
FAIL tests/threads/mlfqs-load-avg
FAIL tests/threads/mlfqs-recent-1
pass tests/threads/mlfqs-fair-2
FAIL tests/threads/mlfqs-fair-20
FAIL tests/threads/mlfqs-nice-2
FAIL tests/threads/mlfqs-nice-10
pass tests/threads/mlfqs-block
pass tests/threads/mlfqs-frac-add
pass tests/threads/mlfqs-frac-sub
pass tests/threads/mlfqs-frac-mult
pass tests/threads/mlfqs-frac-div
pass tests/threads/mlfqs-to-int
```